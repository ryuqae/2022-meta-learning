from dataclasses import replace
import tensorflow as tf
import tensorflow_datasets as tfds
import matplotlib.pyplot as plt
import numpy as np


class DataLoader(object):
    def __init__(
        self,
        data_type: str = "train",
        n_way: int = 5,
        n_support: int = 5,
        n_query: int = 5,
    ):
        self.data_type = data_type
        self.data = self.preprocess_data(
            tfds.load(
                "omniglot", data_dir="./data", split=self.data_type, as_supervised=True
            )
        )

        self.n_way = n_way
        self.n_support = n_support
        self.n_query = n_query
        self.task_list = None

    def preprocess_data(self, dataset):
        print(f"Preprocessing {self.data_type} Omniglot dataset")

        def preprocess(image, label):
            image = tf.image.convert_image_dtype(image, tf.float32)
            image = tf.image.rgb_to_grayscale(image)
            image = tf.image.resize(image, [28, 28])
            return image, label

        data = {}
        for image, label in dataset.map(preprocess):
            image = image.numpy()
            label = str(label.numpy())
            if label not in data:
                data[label] = []
            data[label].append(image)
        # print(len(data.keys()))
        print("Finished preprocessing")

        return data

    def generate_task_list(
        self, n_tasks: int = 100, n_way: int = 0, n_query: int = 0, n_support: int = 0
    ):
        n_way = self.n_way if n_way == 0 else n_way
        n_query = self.n_query if n_query == 0 else n_query
        n_support = self.n_support if n_support == 0 else n_support
        task_list = list()
        ############### Your code here ###################
        # TODO: finish implementing this method.
        # Append n_tasks number of tasks to task_list
        # where each task is a dictionary in the form of
        # {label: [random sequence]}
        # Hint: the keys of self.data can be used as labels

        for _ in range(n_tasks):
            selected_labels = np.random.choice(
                list(self.data.keys()), n_way, replace=False
            )
            task = {
                label: np.random.choice(
                    range(len(self.data[label])), n_query + n_support, replace=False
                )
                for label in selected_labels
            }
            task_list.append(task)
        ##################################################
        self.task_list = task_list

    def delete_task_list(self):
        self.task_list = None

    def visualize_random_task(self):
        s, _ = self.data_generator()

        for img in s:
            fig, axs = plt.subplots(
                1, self.n_support, figsize=(self.n_support, self.n_way)
            )
            for i in range(self.n_support):
                axs[i].imshow(img[i].squeeze(), cmap="gray")
                axs[i].axis("off")

        plt.show()

    def data_generator(self, task_idx=0):
        if self.task_list != None:
            # Deterministic task from predefined task space
            assert task_idx >= 0
            task = self.task_list[task_idx]

        else:
            self.generate_task_list(n_tasks=1)
            task = self.task_list[0]
            self.delete_task_list()

        support = np.zeros([self.n_way, self.n_support, 28, 28, 1], dtype=np.float32)
        query = np.zeros([self.n_way, self.n_query, 28, 28, 1], dtype=np.float32)

        ############### Your code here ###################
        # TODO: finish implementing this method.
        # Using a task generated by generate_task_list,
        # create a support and query dataset with shapes
        # (n_way, n_support/n_query, 28, 28, 1)

        support_temp = list()
        query_temp = list()

        for label in task.keys():
            support_idx = task[label][: self.n_support]
            support_temp.append(np.array(self.data[label])[support_idx])

            query_idx = task[label][self.n_support :]
            query_temp.append(np.array(self.data[label])[query_idx])

            support, query = np.array(support_temp), np.array(query_temp)

        ##################################################

        return support, query

    def random_data_generator(self, N):
        n_ways = [2, 3, 5, 6, 10, 15]
        n_shots = [15, 10, 6, 5, 3, 2]

        n_way = 0
        n_support = 0
        n_query = 0

        ############### Your code here ###################
        # TODO: Find numbers for n_way, n_support, n_query
        # where n_way * (n_support + n_query) == 30

        n_ways = [n for n in range(2, N) if (N % n == 0) & (N / n > 3)]
        n_way = np.random.choice(n_ways)
        upper = int(N / n_way)
        shots = list(range(2, upper - 1))
        shot_pairs = list(zip(upper - np.array(shots), np.array(shots)))
        idx = np.random.choice(len(shots))
        n_support, n_query = shot_pairs[idx]

        print(f"N: {N}, n_way: {n_way}, n_support: {n_support}, n_query: {n_query}")

        ##################################################

        assert n_way * (n_support + n_query) == N

        # Generate a random task
        self.generate_task_list(
            n_tasks=1, n_way=n_way, n_support=n_support, n_query=n_query
        )
        task = self.task_list[0]
        self.delete_task_list()

        support = np.zeros([n_way, n_support, 28, 28, 1], dtype=np.float32)
        query = np.zeros([n_way, n_query, 28, 28, 1], dtype=np.float32)

        ############### Your code here ###################
        # TODO: finish implementing this method.
        # create a support and query dataset with shapes
        # (n_way, n_support/n_query, 28, 28, 1)
        # (Same as in the data_generator method)

        support_temp = list()
        query_temp = list()

        for label in task.keys():

            support_idx = task[label][:n_support]
            support_temp.append(np.array(self.data[label])[support_idx])

            query_idx = task[label][n_support:]
            query_temp.append(np.array(self.data[label])[query_idx])

            support, query = np.array(support_temp), np.array(query_temp)

        ##################################################

        return support, query
